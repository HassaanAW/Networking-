import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph, find_path


class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.graph= Graph(undirected=True)
        self.address = addr
        self.seqno = 0
        self.neighbors = {}
        self.port_handle = {}
        self.LSP_seqno = {}
        self.LSP_info = {}
        self.port_address = {}

        # Hints: initialize local state
        pass


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            try:
                path = find_path(self.graph, self.address, packet.dstAddr)
                nodes = path.nodes
                next_hop = nodes[1]
                self.send(self.port_handle[next_hop], packet)
            except:
                pass
        else:
            check = 0   
            retrieve = loads(packet.content)
            neigbhor_info = retrieve[0]
            seq = retrieve[1]
            gen = packet.srcAddr
            store_key = []
            
            if(gen in self.LSP_info):
                n_list = self.LSP_info[gen]
                for key, value in n_list.items():
                    store_key.append(key)
            
            if(packet.srcAddr in self.LSP_seqno):
                if(seq <= self.LSP_seqno[packet.srcAddr] ):
                    check = 0 
                    pass # discarding packet
                else: # update LSP_seqno and LSP_info. Then update graph
                    
                    for x in store_key:
                        try:
                            self.graph.remove_edge(gen,x)
                        except:
                            pass

                    self.LSP_seqno.update({packet.srcAddr: seq}) # latest seqno stored
                    self.LSP_info.update({packet.srcAddr: neigbhor_info} ) # lastest neighbor info stored
                    check = 1
            else:
                self.LSP_seqno.update({packet.srcAddr: seq}) # latest seqno stored
                self.LSP_info.update({packet.srcAddr: neigbhor_info} ) # lastest neighbor info stored
                check = 1

            if(check == 1): # valid packet
                # update graph
                for key,value in neigbhor_info.items():
                    self.graph.add_edge(packet.srcAddr, key, value)

                for key in self.neighbors:
                    if(self.port_handle[key]== port):
                        #print("not sent to", key)
                        pass
                    else: 
                        self.send(self.port_handle[key], packet)
                        #print("Sent to", key)
            else:
                pass
            
            #print(self.address, "graph", self.graph)
            #print("src", packet.srcAddr, "neighbors", neigbhor_info, "seq", seq, "LSP_seq", self.LSP_seqno, "LSPinfo", self.LSP_info)
           
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        #print("Ports: ", port, "Endpoint:", endpoint)
        #print("Self", self.address, "->", endpoint)
        
        self.graph.add_edge(self.address, endpoint, cost)
        self.neighbors.update({endpoint:cost})
        self.port_handle.update( {endpoint:port} )
        self.port_address.update({port:endpoint}) 
        # create an LSP and flood
        for key in self.neighbors:
            packet = Packet(Packet.ROUTING, self.address, key)
            to_send = (self.neighbors, self.seqno)
            packet.content = dumps(to_send)
            self.send(self.port_handle[key], packet)
            
        self.LSP_seqno.update({self.address: self.seqno})
        self.LSP_info.update({self.address: self.neighbors})

        self.seqno = self.seqno + 1

        pass


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        
        #print("init", self.neighbors)
        get_add = self.port_address[port]
        #print(get_add)
        del self.neighbors[get_add]
        self.graph.remove_edge(self.address, get_add)
        del self.port_handle[get_add]
        del self.port_address[port]

        #print("after",self.neighbors)

        for key in self.neighbors:
            packet = Packet(Packet.ROUTING, self.address, key)
            to_send = (self.neighbors, self.seqno)
            packet.content = dumps(to_send)
            self.send(self.port_handle[key], packet)

        self.LSP_seqno.update({self.address: self.seqno})
        self.LSP_info.update({self.address: self.neighbors})

        self.seqno = self.seqno + 1
        pass


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs

            # Hints:
            #broadcast the link state of this router to all neighbors
            for key in self.neighbors:
                packet = Packet(Packet.ROUTING, self.address, key)
                to_send = (self.neighbors, self.seqno)
                packet.content = dumps(to_send)
                self.send(self.port_handle[key], packet)
            
            self.LSP_seqno.update({self.address: self.seqno})
            self.LSP_info.update({self.address: self.neighbors})

            self.seqno = self.seqno + 1
            pass


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return ""
